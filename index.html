<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waypoint Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #16213e;
            border-bottom: 2px solid #0f3460;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }
        .header h1 {
            font-size: 1.2em;
            margin: 0;
            margin-right: 20px;
            color: #e94560;
        }
        .header .mode-buttons {
            display: flex;
            gap: 8px;
            flex: 1;
        }
        .header .mode-buttons .btn {
            padding: 8px 16px;
            margin: 0;
            font-size: 0.9em;
            min-width: 90px;
        }
        .container {
            display: flex;
            height: 100vh;
            padding-top: 60px;
        }
        .sidebar {
            width: 320px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0f0f23;
        }
        #mapCanvas {
            cursor: crosshair;
        }
        h1 {
            font-size: 1.4em;
            margin-bottom: 20px;
            color: #e94560;
        }
        h2 {
            font-size: 1.1em;
            margin: 20px 0 10px 0;
            color: #0f3460;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 5px;
            color: #e94560;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: #1a1a2e;
            border-radius: 8px;
        }
        label {
            display: block;
            margin: 10px 0 5px 0;
            font-size: 0.9em;
            color: #aaa;
        }
        input[type="file"] {
            width: 100%;
            padding: 8px;
            background: #0f3460;
            border: none;
            border-radius: 4px;
            color: #eee;
            cursor: pointer;
        }
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            border-radius: 4px;
            color: #eee;
        }
        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #e94560;
        }
        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #e94560;
            color: white;
        }
        .btn-primary:hover {
            background: #ff6b6b;
        }
        .btn-secondary {
            background: #0f3460;
            color: #eee;
        }
        .btn-secondary:hover {
            background: #1a4a7e;
        }
        .btn-danger {
            background: #8b0000;
            color: white;
        }
        .btn-danger:hover {
            background: #a52a2a;
        }
        .btn-warning {
            background: #ffa500;
            color: #1a1a2e;
        }
        .btn-warning:hover {
            background: #ffb733;
        }
        .mode-buttons {
            display: flex;
            gap: 5px;
        }
        .mode-buttons .btn {
            flex: 1;
        }
        .mode-buttons .btn.active {
            background: #e94560;
            color: white;
        }
        .waypoint-list {
            max-height: 300px;
            overflow-y: auto;
            background: #0f3460;
            border-radius: 4px;
            padding: 5px;
        }
        .waypoint-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 3px 0;
            background: #16213e;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .waypoint-item.pause {
            background: #3d2e00;
            border-left: 3px solid #ffa500;
        }
        .waypoint-item.wait-topic {
            background: #002e3d;
            border-left: 3px solid #00bcd4;
        }
        .waypoint-item .index {
            width: 25px;
            font-weight: bold;
            color: #e94560;
        }
        .waypoint-item .coords {
            flex: 1;
        }
        .waypoint-item .actions {
            display: flex;
            gap: 3px;
        }
        .waypoint-item .actions button {
            padding: 3px 8px;
            font-size: 0.8em;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .waypoint-item .actions .pause-btn {
            background: #ffa500;
            color: #1a1a2e;
        }
        .waypoint-item .actions .pause-btn.paused {
            background: #4caf50;
        }
        .waypoint-item .actions .pause-btn.wait-topic {
            background: #00bcd4;
        }
        .waypoint-item .actions .delete-btn {
            background: #8b0000;
            color: white;
        }
        .info-box {
            padding: 10px;
            background: #0f3460;
            border-radius: 4px;
            font-size: 0.85em;
            line-height: 1.6;
        }
        .info-box code {
            background: #1a1a2e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4caf50;
        }
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 20px;
            background: rgba(22, 33, 62, 0.95);
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .zoom-controls button {
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            border: none;
            border-radius: 4px;
            background: #16213e;
            color: #eee;
            cursor: pointer;
        }
        .zoom-controls button:hover {
            background: #0f3460;
        }
        .help-text {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Waypoint Editor</h1>
        <div class="mode-buttons">
            <button class="btn btn-secondary active" id="modePoint" onclick="setMode('point')">
                ポイント <span style="opacity: 0.6; font-size: 0.85em;">(1)</span>
            </button>
            <button class="btn btn-secondary" id="modeLine" onclick="setMode('line')">
                ライン <span style="opacity: 0.6; font-size: 0.85em;">(2)</span>
            </button>
            <button class="btn btn-secondary" id="modeSmartPath" onclick="setMode('smartPath')">
                経路計画 <span style="opacity: 0.6; font-size: 0.85em;">(3)</span>
            </button>
            <button class="btn btn-secondary" id="modeSelect" onclick="setMode('select')">
                選択 <span style="opacity: 0.6; font-size: 0.85em;">(4)</span>
            </button>
            <button class="btn btn-secondary" id="modePan" onclick="setMode('pan')">
                移動 <span style="opacity: 0.6; font-size: 0.85em;">(5)</span>
            </button>
        </div>
    </div>
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h2>マップ設定</h2>
                <label>PGMファイル</label>
                <input type="file" id="pgmFile" accept=".pgm,.png,.jpg">

                <label>YAMLファイル（オプション）</label>
                <input type="file" id="yamlFile" accept=".yaml,.yml">

                <label>解像度 (m/pixel)</label>
                <input type="number" id="resolution" value="0.05" step="0.001">

                <label>原点 X (m)</label>
                <input type="number" id="originX" value="-102" step="0.1">

                <label>原点 Y (m)</label>
                <input type="number" id="originY" value="-141" step="0.1">
            </div>

            <div class="section">
                <h2>操作方法</h2>
                <p class="help-text">
                    <strong>ポイント (1):</strong> クリックで追加<br>
                    <strong>ライン (2):</strong> ドラッグで描画<br>
                    <strong>経路計画 (3):</strong> 開始→終了点で自動生成<br>
                    <strong>選択 (4):</strong> ドラッグで移動<br>
                    &nbsp;&nbsp;ダブルクリック/Wで待機トグル<br>
                    &nbsp;&nbsp;Delete/Backspaceで削除<br>
                    <strong>移動 (5):</strong> ドラッグで画面移動
                </p>

                <label>ライン間隔 (m)</label>
                <input type="number" id="lineInterval" value="0.5" step="0.1" min="0.1">
            </div>

            <div class="section">
                <h2>ウェイポイント (<span id="waypointCount">0</span>)</h2>
                <div class="waypoint-list" id="waypointList">
                    <p style="color: #666; padding: 10px;">ウェイポイントがありません</p>
                </div>
                <button class="btn btn-danger" onclick="clearWaypoints()">すべて削除</button>
                <button class="btn btn-secondary" onclick="undoLast()">元に戻す</button>
            </div>

            <div class="section">
                <h2>エクスポート</h2>
                <button class="btn btn-primary" onclick="exportCSV()">CSV出力</button>
                <button class="btn btn-secondary" onclick="importCSV()">CSV読込</button>
                <input type="file" id="csvImport" accept=".csv" style="display: none;">

                <div class="info-box" style="margin-top: 10px;">
                    <strong>CSV形式:</strong><br>
                    <code>x,y,yaw,pause_sec</code><br>
                    x, y: 位置 (メートル)<br>
                    yaw: 向き (ラジアン)<br>
                    pause_sec:<br>
                    &nbsp; 0 = 待機なし<br>
                    &nbsp; -1 = トピック待機
                </div>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="mapCanvas"></canvas>
            <div class="zoom-controls">
                <button onclick="zoomIn()">+</button>
                <button onclick="zoomOut()">-</button>
                <button onclick="resetView()">R</button>
            </div>
            <div class="status-bar">
                <span id="mouseCoords">Mouse: -</span>
                <span id="worldCoords">World: -</span>
                <span id="zoomLevel">Zoom: 100%</span>
            </div>
        </div>
    </div>

    <script>
        // State
        let mapImage = null;
        let waypoints = [];
        let currentMode = 'point';
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let isDrawingLine = false;
        let isDraggingWaypoint = false;
        let selectedWaypointIndex = -1;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let linePoints = [];
        let smartPathStart = null;
        let smartPathEnd = null;
        let obstacleMap = null;
        let lastClickTime = 0;
        let lastClickIndex = -1;

        // Map parameters
        let resolution = 0.05;
        let originX = -102;
        let originY = -141;
        let imageWidth = 0;
        let imageHeight = 0;

        // Canvas
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            canvas.addEventListener('wheel', onWheel);

            // Add keyboard event listener for Delete key
            document.addEventListener('keydown', onKeyDown);

            document.getElementById('resolution').addEventListener('change', updateResolution);
            document.getElementById('originX').addEventListener('change', updateOrigin);
            document.getElementById('originY').addEventListener('change', updateOrigin);
            document.getElementById('pgmFile').addEventListener('change', loadPGM);
            document.getElementById('yamlFile').addEventListener('change', loadYAML);
            document.getElementById('csvImport').addEventListener('change', handleCSVImport);

            render();
        }

        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-buttons .btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');

            if (mode === 'pan') {
                canvas.style.cursor = 'grab';
            } else if (mode === 'select') {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'crosshair';
            }

            // Clear selection when changing mode
            if (mode !== 'select') {
                selectedWaypointIndex = -1;
            }

            // Clear smart path selection
            if (mode !== 'smartPath') {
                smartPathStart = null;
                smartPathEnd = null;
            }

            render();
        }

        function loadPGM(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const data = new Uint8Array(event.target.result);

                // Check if it's a binary PGM (P5)
                if (data[0] === 80 && data[1] === 53) { // "P5"
                    parsePGM(data);
                } else {
                    // Try as regular image
                    const img = new Image();
                    img.onload = function() {
                        mapImage = img;
                        imageWidth = img.width;
                        imageHeight = img.height;
                        buildObstacleMap();
                        resetView();
                    };
                    img.src = URL.createObjectURL(file);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function parsePGM(data) {
            // Parse P5 PGM format
            let idx = 0;

            // Skip magic number "P5"
            while (data[idx] !== 10) idx++;
            idx++;

            // Skip comments
            while (data[idx] === 35) { // '#'
                while (data[idx] !== 10) idx++;
                idx++;
            }

            // Parse width and height
            let numStr = '';
            while (data[idx] !== 32 && data[idx] !== 10) {
                numStr += String.fromCharCode(data[idx]);
                idx++;
            }
            const width = parseInt(numStr);
            idx++;

            numStr = '';
            while (data[idx] !== 10) {
                numStr += String.fromCharCode(data[idx]);
                idx++;
            }
            const height = parseInt(numStr);
            idx++;

            // Parse max value
            numStr = '';
            while (data[idx] !== 10) {
                numStr += String.fromCharCode(data[idx]);
                idx++;
            }
            idx++;

            // Create image from pixel data
            const imgCanvas = document.createElement('canvas');
            imgCanvas.width = width;
            imgCanvas.height = height;
            const imgCtx = imgCanvas.getContext('2d');
            const imageData = imgCtx.createImageData(width, height);

            for (let i = 0; i < width * height; i++) {
                const val = data[idx + i];
                imageData.data[i * 4] = val;
                imageData.data[i * 4 + 1] = val;
                imageData.data[i * 4 + 2] = val;
                imageData.data[i * 4 + 3] = 255;
            }

            imgCtx.putImageData(imageData, 0, 0);

            const img = new Image();
            img.onload = function() {
                mapImage = img;
                imageWidth = width;
                imageHeight = height;
                buildObstacleMap();
                resetView();
            };
            img.src = imgCanvas.toDataURL();
        }

        // Build obstacle map from image
        function buildObstacleMap() {
            if (!mapImage) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageWidth;
            tempCanvas.height = imageHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(mapImage, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, imageWidth, imageHeight);
            const data = imageData.data;

            obstacleMap = new Array(imageHeight);
            for (let y = 0; y < imageHeight; y++) {
                obstacleMap[y] = new Array(imageWidth);
                for (let x = 0; x < imageWidth; x++) {
                    const idx = (y * imageWidth + x) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    // Threshold: darker pixels are obstacles
                    obstacleMap[y][x] = brightness < 128 ? 1 : 0;
                }
            }
        }

        // A* pathfinding algorithm
        function findPath(startPx, startPy, endPx, endPy) {
            if (!obstacleMap) return null;

            const start = { x: Math.round(startPx), y: Math.round(startPy) };
            const end = { x: Math.round(endPx), y: Math.round(endPy) };

            // Check bounds
            if (start.x < 0 || start.x >= imageWidth || start.y < 0 || start.y >= imageHeight) return null;
            if (end.x < 0 || end.x >= imageWidth || end.y < 0 || end.y >= imageHeight) return null;

            const openSet = [start];
            const cameFrom = {};
            const gScore = {};
            const fScore = {};
            const key = (p) => `${p.x},${p.y}`;

            gScore[key(start)] = 0;
            fScore[key(start)] = heuristic(start, end);

            while (openSet.length > 0) {
                // Find node with lowest fScore
                let current = openSet[0];
                let currentIdx = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore[key(openSet[i])] < fScore[key(current)]) {
                        current = openSet[i];
                        currentIdx = i;
                    }
                }

                // Reached goal
                if (current.x === end.x && current.y === end.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(currentIdx, 1);

                // Check neighbors
                const neighbors = [
                    { x: current.x - 1, y: current.y },
                    { x: current.x + 1, y: current.y },
                    { x: current.x, y: current.y - 1 },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x - 1, y: current.y - 1 },
                    { x: current.x + 1, y: current.y - 1 },
                    { x: current.x - 1, y: current.y + 1 },
                    { x: current.x + 1, y: current.y + 1 }
                ];

                for (const neighbor of neighbors) {
                    // Check bounds and obstacles
                    if (neighbor.x < 0 || neighbor.x >= imageWidth ||
                        neighbor.y < 0 || neighbor.y >= imageHeight ||
                        obstacleMap[neighbor.y][neighbor.x] === 1) {
                        continue;
                    }

                    const isDiagonal = neighbor.x !== current.x && neighbor.y !== current.y;
                    const tentativeGScore = gScore[key(current)] + (isDiagonal ? 1.414 : 1);

                    if (!(key(neighbor) in gScore) || tentativeGScore < gScore[key(neighbor)]) {
                        cameFrom[key(neighbor)] = current;
                        gScore[key(neighbor)] = tentativeGScore;
                        fScore[key(neighbor)] = gScore[key(neighbor)] + heuristic(neighbor, end);

                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            return null; // No path found
        }

        function heuristic(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function reconstructPath(cameFrom, current) {
            const path = [current];
            const key = (p) => `${p.x},${p.y}`;

            while (key(current) in cameFrom) {
                current = cameFrom[key(current)];
                path.unshift(current);
            }

            return path;
        }

        function loadYAML(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const text = event.target.result;
                const lines = text.split('\n');

                for (const line of lines) {
                    if (line.startsWith('resolution:')) {
                        resolution = parseFloat(line.split(':')[1].trim());
                        document.getElementById('resolution').value = resolution;
                    } else if (line.startsWith('origin:')) {
                        const match = line.match(/\[([^,]+),\s*([^,]+)/);
                        if (match) {
                            originX = parseFloat(match[1]);
                            originY = parseFloat(match[2]);
                            document.getElementById('originX').value = originX;
                            document.getElementById('originY').value = originY;
                        }
                    }
                }
                render();
            };
            reader.readAsText(file);
        }

        function updateResolution() {
            resolution = parseFloat(document.getElementById('resolution').value) || 0.05;
            render();
        }

        function updateOrigin() {
            originX = parseFloat(document.getElementById('originX').value) || 0;
            originY = parseFloat(document.getElementById('originY').value) || 0;
            render();
        }

        // Coordinate conversion
        function pixelToWorld(px, py) {
            // PGM origin is top-left, ROS map origin is bottom-left
            const worldX = originX + px * resolution;
            const worldY = originY + (imageHeight - py) * resolution;
            return { x: worldX, y: worldY };
        }

        function worldToPixel(wx, wy) {
            const px = (wx - originX) / resolution;
            const py = imageHeight - (wy - originY) / resolution;
            return { x: px, y: py };
        }

        function screenToPixel(sx, sy) {
            return {
                x: (sx - offsetX) / scale,
                y: (sy - offsetY) / scale
            };
        }

        function pixelToScreen(px, py) {
            return {
                x: px * scale + offsetX,
                y: py * scale + offsetY
            };
        }

        // Find waypoint at screen position (returns index or -1)
        function findWaypointAtPosition(sx, sy) {
            const clickRadius = 15; // pixels

            for (let i = waypoints.length - 1; i >= 0; i--) {
                const wp = waypoints[i];
                const pixel = worldToPixel(wp.x, wp.y);
                const screen = pixelToScreen(pixel.x, pixel.y);

                const dx = screen.x - sx;
                const dy = screen.y - sy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= clickRadius) {
                    return i;
                }
            }
            return -1;
        }

        // Event handlers
        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            lastMouseX = sx;
            lastMouseY = sy;

            if (currentMode === 'pan') {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            } else if (currentMode === 'select') {
                const wpIndex = findWaypointAtPosition(sx, sy);
                if (wpIndex !== -1) {
                    // Check for double-click
                    const currentTime = Date.now();
                    if (wpIndex === lastClickIndex && currentTime - lastClickTime < 300) {
                        // Double-click detected - toggle wait state
                        togglePause(wpIndex);
                        lastClickTime = 0;
                        lastClickIndex = -1;
                    } else {
                        // Single click - select and prepare to drag
                        selectedWaypointIndex = wpIndex;
                        isDraggingWaypoint = true;
                        canvas.style.cursor = 'move';
                        lastClickTime = currentTime;
                        lastClickIndex = wpIndex;
                    }
                    render();
                } else {
                    selectedWaypointIndex = -1;
                    lastClickTime = 0;
                    lastClickIndex = -1;
                    render();
                }
            } else if (currentMode === 'point') {
                const pixel = screenToPixel(sx, sy);
                if (mapImage && pixel.x >= 0 && pixel.x < imageWidth && pixel.y >= 0 && pixel.y < imageHeight) {
                    const world = pixelToWorld(pixel.x, pixel.y);
                    addWaypoint(world.x, world.y, 0, 0);
                }
            } else if (currentMode === 'line') {
                isDrawingLine = true;
                linePoints = [];
                const pixel = screenToPixel(sx, sy);
                if (mapImage) {
                    linePoints.push(pixel);
                }
            } else if (currentMode === 'smartPath') {
                const pixel = screenToPixel(sx, sy);
                if (mapImage && pixel.x >= 0 && pixel.x < imageWidth && pixel.y >= 0 && pixel.y < imageHeight) {
                    if (!smartPathStart) {
                        smartPathStart = pixel;
                        render();
                    } else {
                        smartPathEnd = pixel;
                        generateSmartPath();
                        smartPathStart = null;
                        smartPathEnd = null;
                        render();
                    }
                }
            }
        }

        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            // Update status bar
            const pixel = screenToPixel(sx, sy);
            document.getElementById('mouseCoords').textContent = `Pixel: (${pixel.x.toFixed(0)}, ${pixel.y.toFixed(0)})`;

            if (mapImage && pixel.x >= 0 && pixel.x < imageWidth && pixel.y >= 0 && pixel.y < imageHeight) {
                const world = pixelToWorld(pixel.x, pixel.y);
                document.getElementById('worldCoords').textContent = `World: (${world.x.toFixed(2)}, ${world.y.toFixed(2)}) m`;
            }

            if (isDraggingWaypoint && selectedWaypointIndex !== -1) {
                const pixel = screenToPixel(sx, sy);
                if (mapImage && pixel.x >= 0 && pixel.x < imageWidth && pixel.y >= 0 && pixel.y < imageHeight) {
                    const world = pixelToWorld(pixel.x, pixel.y);
                    waypoints[selectedWaypointIndex].x = world.x;
                    waypoints[selectedWaypointIndex].y = world.y;
                    updateWaypointList();
                    render();
                }
            } else if (isDragging) {
                offsetX += sx - lastMouseX;
                offsetY += sy - lastMouseY;
                lastMouseX = sx;
                lastMouseY = sy;
                render();
            } else if (isDrawingLine) {
                const pixel = screenToPixel(sx, sy);
                linePoints.push(pixel);
                render();

                // Draw temporary line
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < linePoints.length; i++) {
                    const sp = pixelToScreen(linePoints[i].x, linePoints[i].y);
                    if (i === 0) ctx.moveTo(sp.x, sp.y);
                    else ctx.lineTo(sp.x, sp.y);
                }
                ctx.stroke();
            } else if (currentMode === 'select') {
                // Update cursor based on whether hovering over a waypoint
                const wpIndex = findWaypointAtPosition(sx, sy);
                canvas.style.cursor = wpIndex !== -1 ? 'pointer' : 'default';
            }
        }

        function onMouseUp(e) {
            if (isDraggingWaypoint) {
                isDraggingWaypoint = false;
                canvas.style.cursor = 'pointer';
            }

            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = currentMode === 'pan' ? 'grab' : 'crosshair';
            }

            if (isDrawingLine && linePoints.length > 1) {
                const interval = parseFloat(document.getElementById('lineInterval').value) || 0.5;
                generateWaypointsFromLine(linePoints, interval);
            }
            isDrawingLine = false;
            linePoints = [];
            render();
        }

        function onWheel(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            const oldScale = scale;
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale *= delta;
            scale = Math.max(0.1, Math.min(10, scale));

            // Zoom towards cursor
            offsetX = sx - (sx - offsetX) * (scale / oldScale);
            offsetY = sy - (sy - offsetY) * (scale / oldScale);

            document.getElementById('zoomLevel').textContent = `Zoom: ${(scale * 100).toFixed(0)}%`;
            render();
        }

        function onKeyDown(e) {
            // Mode switching with number keys (1-5)
            // Only if not typing in an input field
            if (!e.target.matches('input, textarea')) {
                if (e.key === '1') {
                    e.preventDefault();
                    setMode('point');
                    return;
                } else if (e.key === '2') {
                    e.preventDefault();
                    setMode('line');
                    return;
                } else if (e.key === '3') {
                    e.preventDefault();
                    setMode('smartPath');
                    return;
                } else if (e.key === '4') {
                    e.preventDefault();
                    setMode('select');
                    return;
                } else if (e.key === '5') {
                    e.preventDefault();
                    setMode('pan');
                    return;
                }
            }

            // Delete or Backspace key - delete selected waypoint
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedWaypointIndex !== -1) {
                e.preventDefault();
                deleteWaypoint(selectedWaypointIndex);
                selectedWaypointIndex = -1;
            }
            // W key - toggle wait state for selected waypoint
            else if ((e.key === 'w' || e.key === 'W') && selectedWaypointIndex !== -1 && !e.target.matches('input, textarea')) {
                e.preventDefault();
                togglePause(selectedWaypointIndex);
            }
        }

        function zoomIn() {
            scale *= 1.2;
            scale = Math.min(10, scale);
            document.getElementById('zoomLevel').textContent = `Zoom: ${(scale * 100).toFixed(0)}%`;
            render();
        }

        function zoomOut() {
            scale *= 0.8;
            scale = Math.max(0.1, scale);
            document.getElementById('zoomLevel').textContent = `Zoom: ${(scale * 100).toFixed(0)}%`;
            render();
        }

        function resetView() {
            if (mapImage) {
                const scaleX = canvas.width / imageWidth;
                const scaleY = canvas.height / imageHeight;
                scale = Math.min(scaleX, scaleY) * 0.9;
                offsetX = (canvas.width - imageWidth * scale) / 2;
                offsetY = (canvas.height - imageHeight * scale) / 2;
            } else {
                scale = 1;
                offsetX = 0;
                offsetY = 0;
            }
            document.getElementById('zoomLevel').textContent = `Zoom: ${(scale * 100).toFixed(0)}%`;
            render();
        }

        // Waypoint management
        function addWaypoint(x, y, yaw, pauseSec) {
            waypoints.push({ x, y, yaw, pauseSec });
            updateWaypointList();
            render();
        }

        function generateWaypointsFromLine(points, interval) {
            if (points.length < 2) return;

            // Calculate total length and sample at intervals
            let totalDist = 0;
            const worldPoints = points.map(p => pixelToWorld(p.x, p.y));

            for (let i = 1; i < worldPoints.length; i++) {
                const dx = worldPoints[i].x - worldPoints[i-1].x;
                const dy = worldPoints[i].y - worldPoints[i-1].y;
                totalDist += Math.sqrt(dx*dx + dy*dy);
            }

            // Add first point
            addWaypoint(worldPoints[0].x, worldPoints[0].y, 0, 0);

            // Sample along the path
            let accDist = 0;
            let lastSampleDist = 0;

            for (let i = 1; i < worldPoints.length; i++) {
                const dx = worldPoints[i].x - worldPoints[i-1].x;
                const dy = worldPoints[i].y - worldPoints[i-1].y;
                const segDist = Math.sqrt(dx*dx + dy*dy);

                let segProgress = 0;
                while (accDist + segProgress < accDist + segDist) {
                    const nextSampleDist = lastSampleDist + interval;
                    const distIntoSeg = nextSampleDist - accDist;

                    if (distIntoSeg <= segDist) {
                        const t = distIntoSeg / segDist;
                        const px = worldPoints[i-1].x + dx * t;
                        const py = worldPoints[i-1].y + dy * t;
                        const yaw = Math.atan2(dy, dx);
                        addWaypoint(px, py, yaw, 0);
                        lastSampleDist = nextSampleDist;
                        segProgress = distIntoSeg;
                    } else {
                        break;
                    }
                }
                accDist += segDist;
            }

            // Calculate yaw for each waypoint based on direction to next
            for (let i = 0; i < waypoints.length - 1; i++) {
                const dx = waypoints[i+1].x - waypoints[i].x;
                const dy = waypoints[i+1].y - waypoints[i].y;
                waypoints[i].yaw = Math.atan2(dy, dx);
            }
            if (waypoints.length > 1) {
                waypoints[waypoints.length-1].yaw = waypoints[waypoints.length-2].yaw;
            }

            updateWaypointList();
        }

        function generateSmartPath() {
            if (!smartPathStart || !smartPathEnd || !obstacleMap) return;

            const path = findPath(smartPathStart.x, smartPathStart.y, smartPathEnd.x, smartPathEnd.y);

            if (!path) {
                alert('経路が見つかりませんでした。障害物がないか確認してください。');
                return;
            }

            // Convert pixel path to waypoints with interval sampling
            const interval = parseFloat(document.getElementById('lineInterval').value) || 0.5;
            generateWaypointsFromLine(path, interval);
        }

        function updateWaypointList() {
            const list = document.getElementById('waypointList');
            document.getElementById('waypointCount').textContent = waypoints.length;

            if (waypoints.length === 0) {
                list.innerHTML = '<p style="color: #666; padding: 10px;">ウェイポイントがありません</p>';
                return;
            }

            list.innerHTML = waypoints.map((wp, i) => {
                let itemClass = '';
                let pauseLabel = '-';
                let pauseBtnClass = '';

                if (wp.pauseSec === -1) {
                    itemClass = 'wait-topic';
                    pauseLabel = 'W';
                    pauseBtnClass = 'wait-topic';
                }

                return `
                <div class="waypoint-item ${itemClass}">
                    <span class="index">${i+1}</span>
                    <span class="coords">
                        (${wp.x.toFixed(2)}, ${wp.y.toFixed(2)})
                        ${wp.pauseSec === -1 ? '<br>トピック待機' : ''}
                    </span>
                    <span class="actions">
                        <button class="pause-btn ${pauseBtnClass}"
                                onclick="togglePause(${i})" title="待機状態をトグル (-=なし, W=トピック待機)">
                            ${pauseLabel}
                        </button>
                        <button class="delete-btn" onclick="deleteWaypoint(${i})" title="削除">X</button>
                    </span>
                </div>
            `}).join('');
        }

        function togglePause(index) {
            // Toggle between 0 (no pause) and -1 (wait for topic)
            waypoints[index].pauseSec = waypoints[index].pauseSec === -1 ? 0 : -1;
            updateWaypointList();
            render();
        }

        function deleteWaypoint(index) {
            waypoints.splice(index, 1);
            updateWaypointList();
            render();
        }

        function clearWaypoints() {
            if (confirm('すべてのウェイポイントを削除しますか？')) {
                waypoints = [];
                updateWaypointList();
                render();
            }
        }

        function undoLast() {
            if (waypoints.length > 0) {
                waypoints.pop();
                updateWaypointList();
                render();
            }
        }

        // Export/Import
        function exportCSV() {
            if (waypoints.length === 0) {
                alert('エクスポートするウェイポイントがありません');
                return;
            }

            let csv = 'x,y,yaw,pause_sec\n';
            for (const wp of waypoints) {
                csv += `${wp.x.toFixed(4)},${wp.y.toFixed(4)},${wp.yaw.toFixed(4)},${wp.pauseSec}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'waypoints.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importCSV() {
            document.getElementById('csvImport').click();
        }

        function handleCSVImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const lines = event.target.result.split('\n');
                waypoints = [];

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 3) {
                        waypoints.push({
                            x: parseFloat(parts[0]),
                            y: parseFloat(parts[1]),
                            yaw: parseFloat(parts[2]),
                            pauseSec: parts.length > 3 ? parseFloat(parts[3]) : 0
                        });
                    }
                }

                updateWaypointList();
                render();
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        // Rendering
        function render() {
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (mapImage) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.drawImage(mapImage, 0, 0);
                ctx.restore();
            }

            // Draw grid
            if (scale > 0.5) {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                const gridSize = 1 / resolution; // 1 meter in pixels
                const scaledGrid = gridSize * scale;

                if (scaledGrid > 20) {
                    const startX = offsetX % scaledGrid;
                    const startY = offsetY % scaledGrid;

                    ctx.beginPath();
                    for (let x = startX; x < canvas.width; x += scaledGrid) {
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                    }
                    for (let y = startY; y < canvas.height; y += scaledGrid) {
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                    }
                    ctx.stroke();
                }
            }

            // Draw waypoints
            for (let i = 0; i < waypoints.length; i++) {
                const wp = waypoints[i];
                const pixel = worldToPixel(wp.x, wp.y);
                const screen = pixelToScreen(pixel.x, pixel.y);

                // Draw connection line to next waypoint
                if (i < waypoints.length - 1) {
                    const nextWp = waypoints[i + 1];
                    const nextPixel = worldToPixel(nextWp.x, nextWp.y);
                    const nextScreen = pixelToScreen(nextPixel.x, nextPixel.y);

                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(screen.x, screen.y);
                    ctx.lineTo(nextScreen.x, nextScreen.y);
                    ctx.stroke();
                }

                // Draw waypoint marker
                let radius = 6;
                let markerColor = '#e94560';
                if (wp.pauseSec === -1) {
                    radius = 10;
                    markerColor = '#00bcd4';
                } else if (wp.pauseSec > 0) {
                    radius = 10;
                    markerColor = '#ffa500';
                }

                // Draw selection indicator
                if (i === selectedWaypointIndex) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.fillStyle = markerColor;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw orientation arrow
                const arrowLen = 15;
                const arrowX = screen.x + Math.cos(-wp.yaw) * arrowLen;
                const arrowY = screen.y + Math.sin(-wp.yaw) * arrowLen;

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screen.x, screen.y);
                ctx.lineTo(arrowX, arrowY);
                ctx.stroke();

                // Draw index number
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.fillText(i + 1, screen.x + 10, screen.y - 5);

                // Draw pause indicator
                if (wp.pauseSec === -1) {
                    ctx.fillStyle = '#00bcd4';
                    ctx.font = 'bold 9px sans-serif';
                    ctx.fillText('WAIT', screen.x + 10, screen.y + 15);
                } else if (wp.pauseSec > 0) {
                    ctx.fillStyle = '#ffa500';
                    ctx.font = 'bold 9px sans-serif';
                    ctx.fillText(`${wp.pauseSec}s`, screen.x + 10, screen.y + 15);
                }
            }

            // Draw smart path markers
            if (currentMode === 'smartPath' && smartPathStart) {
                const screen = pixelToScreen(smartPathStart.x, smartPathStart.y);
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.fillText('開始', screen.x + 12, screen.y + 5);
            }

            // Draw origin marker
            if (mapImage) {
                const originScreen = pixelToScreen(0, imageHeight);
                ctx.strokeStyle = '#00f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(originScreen.x - 10, originScreen.y);
                ctx.lineTo(originScreen.x + 20, originScreen.y);
                ctx.moveTo(originScreen.x, originScreen.y + 10);
                ctx.lineTo(originScreen.x, originScreen.y - 20);
                ctx.stroke();

                ctx.fillStyle = '#00f';
                ctx.font = '12px sans-serif';
                ctx.fillText('原点', originScreen.x + 5, originScreen.y + 20);
            }
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
